/*
 * Calculator example with basic operator overloading (sort of).
 */

{
  class ASTNode {
    evaluate() {
      throw new Error("Unknown node type.");
    }

    toString() {
      return JSON.stringify(this);
    }
  }

  class ASTPrimitive extends ASTNode {
    constructor(value) {
      this.value = value;
    }

    evaluate() {
      return this.value;
    }

    toString() {
      return this.value;
    }
  }

  class BinaryNode extends ASTNode {
    constructor(args) {
      this.lh = args.lh;
      this.op = args.op;
      this.rh = args.rh;
    }

    evaluate() {
      let lho = this.lh.evaluate(), rho = this.rh.evaluate();
      switch (this.op) {
        case "+": return this.lh._add ? this.lh._add(lho, rho) : lho + rho;
        case "-": return this.lh._sub ? this.lh._sub(lho, rho) : lho - rho;
        case "/": return this.lh._div ? this.lh._div(lho, rho) : lho / rho;
        case "*": return this.lh._mul ? this.lh._mul(lho, rho) : lho * rho;
        default: throw new Error("Unknown operator.");
      }
    }
  }

  class UnaryNode extends ASTNode {
    constructor(args) {
      this.op = args.op;
      this.bh = args.bh;
    }

    evaluate() {
      let bho = this.bh.evaluate();
      switch (this.op) {
        case "--": return --bho;
        case "++": return ++bho;
        case "-": return -bho;
        case "+": return +bho;
        default: throw new Error("Unknown operator.");
      }
    }
  }

  class NumericPrim extends ASTPrimitive {
    constructor(args) {
      super(parseInt(args.value, 10));
    }
  }

  class SpecialPrim extends NumericPrim {
    _add(lho, rho) {
      return lho - rho;
    }

    _sub(lho, rho) {
      return lho + rho;
    }
  }
}

start
  = body:additive ws* { return body.evaluate(); }

additive
  = lh:mult ws* op:additive_op ws* rh:additive { return new BinaryNode({lh, op, rh}); }
  / mult

mult
  = lh:unary ws* op:mult_op ws* rh:mult { return new BinaryNode({lh, op: op, rh}); }
  / unary

unary
  = op:unary_op bh:primary { return new UnaryNode({bh, op}); }
  / primary

primary
  = specialteger
  / integer
  / "(" additive:additive ")" { return additive; }

additive_op = "+" / "-"
mult_op = "*" / "/"
unary_op = "--" / "++" / "-" / "+"

specialteger
  = "s_" digits:[0-9]+ { return new SpecialPrim({value: digits.join("")}); }

integer "integer"
  = digits:[0-9]+ { return new NumericPrim({value: digits.join("")}); }

ws
  = [ \t\r\n] { return null; }
