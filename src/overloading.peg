/*
 * Classic example grammar, which recognizes simple arithmetic expressions like
 * "2*(3+4)". The parser generated from this grammar then computes their value.
 */

{
  class ASTNode {
    evaluate() {
      throw new Error("Unknown node type.");
    }

    toString() {
      return JSON.stringify(this);
    }
  }

  class ASTPrimitive extends ASTNode {
    constructor(value) {
      this.value = value;
    }

    evaluate() {
      return this.value;
    }

    toString() {
      return this.value;
    }
  }

  class BinaryNode extends ASTNode {
    constructor(args) {
      this.lh = args.lh;
      this.op = args.op;
      this.rh = args.rh;
    }

    evaluate() {
      var lho = this.lh.evaluate(), rho = this.rh.evaluate();
      switch (this.op) {
        case "+": return this.lh._add ? this.lh._add(lho, rho) : lho + rho;
        case "-": return this.lh._sub ? this.lh._sub(lho, rho) : lho - rho;
        case "/": return this.lh._div ? this.lh._div(lho, rho) : lho / rho;
        case "*": return this.lh._mul ? this.lh._mul(lho, rho) : lho * rho;
        default: throw new Error("Unknown operator.");
      }
    }
  }

  class UnaryNode extends ASTNode {
    constructor(args) {
      this.op = args.op;
      this.bh = args.bh;
    }

    evaluate() {
      var bho = this.bh.evaluate();
      switch (this.op) {
        case "--": return --bho;
        case "++": return ++bho;
        case "-": return -bho;
        case "+": return +bho;
        default: throw new Error("Unknown operator.");
      }
    }
  }

  class NumericPrim extends ASTPrimitive {
    constructor(args) {
      super(parseInt(args.value, 10));
    }
  }

  class SpecialPrim extends NumericPrim {
    _add(lho, rho) {
      return lho - rho;
    }

    _sub(lho, rho) {
      return lho + rho;
    }
  }
}

start
  = body:additive { return body.evaluate(); }

additive
  = lh:multiplicative op:OPER_ADD rh:additive { return new BinaryNode({lh, op, rh}); }
  / multiplicative

multiplicative
  = lh:unary op:OPER_MUL rh:multiplicative { return new BinaryNode({lh, op: op, rh}); }
  / unary

unary
  = "--" bh:primary { return new UnaryNode({bh, op: "--"}); }
  / "++" bh:primary { return new UnaryNode({bh, op: "++"}); }
  / "-" bh:primary { return new UnaryNode({bh, op: "-"}); }
  / "+" bh:primary { return new UnaryNode({bh, op: "+"}); }
  / primary

primary
  = specialteger
  / integer
  / "(" additive:additive ")" { return additive; }


OPER_ADD = "+" / "-"
OPER_MUL = "*" / "/"

specialteger
  = "s_" digits:[0-9]+ { return new SpecialPrim({value: digits.join("")}); }

integer "integer"
  = digits:[0-9]+ { return new NumericPrim({value: digits.join("")}); }
